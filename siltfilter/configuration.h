#include "helpers.h"

/* configuration */

typedef struct config {
    /* main limit on search is # of prefixes to explore */
    bool allow_dup_prefix = false;
    int max_prefix = 0;
    int brute_depth = 4;
    long seed = 0;
    int range_bytes = 0;
    bool show_tick = false;
    int jobs = 1;
    bool force_core = false;
    int core = 0;
    /* run as root to allow access to cr0.  this will allow most memory accesses
     * generated by the injector to succeed rather than fault, which permits
     * improved fault analysis (e.g. sigsegv will preempt sigfpe; eliminating
     * the initial sigsegv will allow reception of the more descriptive signals) */
    bool enable_null_access = false;
    bool nx_support = true;
} config_t;

/* 32bit vs 64bit */

#ifdef _M_AMD64
#define IP REG_RIP 
#else
#define IP REG_EIP 
#endif

/* leave state as 0 */
/* : encourages instructions to access a consistent address (0) */
/* : avoids crashing the injector (e.g. incidental write to .data) */
/* only change when necessary for synthesizing specific instructions */

#ifdef _M_AMD64
typedef struct {
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD64 Rip;
} state_t;
#else
typedef struct {
    uint32_t eax;
    uint32_t ebx;
    uint32_t ecx;
    uint32_t edx;
    uint32_t esi;
    uint32_t edi;
    uint32_t ebp;
    uint32_t esp;
} state_t;
#endif

typedef struct insn_t {
    uint8_t bytes[MAX_INSN_LENGTH];
    size_t len; /* the number of specified bytes in the instruction */

    // constructor to set bytes and len
    insn_t(uint8_t byte = 0x00, size_t length = 0) {
        std::fill_n(bytes, MAX_INSN_LENGTH, byte);
        len = length;
    }
} insn;

typedef struct inj_t{
    insn i;
    int index;
    int last_len;
    int last_ec;
} inj;

#pragma pack(push, 1) // ensure that structure is packed
typedef struct result_t {
    uint32_t valid;
    uintptr_t length;
    DWORD exceptionCode; // analogous to 'signum'
    uint32_t exceptionFlags; // analogous to 'si_code'
    PVOID faultingAddress; // analogous to 'addr'
}result;
#pragma pack(pop) // turn packing back to default

#pragma pack(push, 1) // ensure that structure is packed
typedef struct disas_t{
#ifdef RAW_REPORT_DISAS_MNE
    char mne[RAW_REPORT_DISAS_MNE_BYTES];
#endif
#ifdef RAW_REPORT_DISAS_OPS
    char ops[RAW_REPORT_DISAS_OPS_BYTES];
#endif
#ifdef RAW_REPORT_DISAS_LEN
    int len;
#endif
#ifdef RAW_REPORT_DISAS_VAL
    int val;
#endif
} disas;
#pragma pack(pop) // turn packing back to default

struct ignore_op_t {
    char* opcode;
    const char* reason;
}ignore_op;

struct ignore_pre_t {
    const char* prefix;
    const char* reason;
}ignore_pre;

struct range_t {
    insn start;
    insn end;
    bool started;

    // constructor to set start, end and started
    range_t(insn_t s = insn_t(), insn_t e = insn_t(), bool st = false)
        : start(s), end(e), started(st) {}
};
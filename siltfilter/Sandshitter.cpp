#include <windows.h>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cassert>
#include <random>
#include <string>
#include <intrin.h>

/*               Instruction Encoding
*  +------Prefix---+---Op------+--ModR/M--+---SIB----+---Displacement---+---Immediate---+
*  |   1 to 4      |  1 to 3   |   1Byte  |  1Byte   |    1/2/4 Bytes   |  1/2/4 Bytes  |
*  +---+---+---+---+---+---+---+----------+----------+------------------+---------------+
*  |1 to 17 bytes
*  |
*  +
*/

/* configuration */

typedef struct config {
    /* main limit on search is # of prefixes to explore */
    bool allow_dup_prefix = false;
    int max_prefix = 0;
    int brute_depth = 4;
    long seed = 0;
    int range_bytes = 0;
    bool show_tick = false;
    int jobs = 1;
    bool force_core = false;
    int core = 0;
    /* run as root to allow access to cr0.  this will allow most memory accesses
     * generated by the injector to succeed rather than fault, which permits
     * improved fault analysis (e.g. sigsegv will preempt sigfpe; eliminating
     * the initial sigsegv will allow reception of the more descriptive signals) */
    bool enable_null_access = false;
    bool nx_support = true;
} config_t;

/* capstone */

#define USE_CAPSTONE true /* sifter offloads some capstone work to injector */

#if USE_CAPSTONE
#include <capstone/capstone.h>
#if _M_AMD64
#define CS_MODE CS_MODE_64
#else
#define CS_MODE CS_MODE_32
#endif
#endif

#if USE_CAPSTONE
csh capstone_handle;
cs_insn* capstone_insn;
#endif

/* 32bit vs 64bit */

#ifdef _M_AMD64
#define IP REG_RIP 
#else
#define IP REG_EIP 
#endif

/* leave state as 0 */
/* : encourages instructions to access a consistent address (0) */
/* : avoids crashing the injector (e.g. incidental write to .data) */
/* only change when necessary for synthesizing specific instructions */

#ifdef _M_AMD64
typedef struct {
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    DWORD64 Rax;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rbx;
    DWORD64 Rsp;
    DWORD64 Rbp;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD64 Rip;
} state_t;
state_t injector_state = {
    injector_state.Rax = 0,
    injector_state.Rbx = 0,
    injector_state.Rcx = 0,
    injector_state.Rdx = 0,
    injector_state.Rsi = 0,
    injector_state.Rdi = 0,
    injector_state.R8 = 0,
    injector_state.R9 = 0,
    injector_state.R10 = 0,
    injector_state.R11 = 0,
    injector_state.R12 = 0,
    injector_state.R13 = 0,
    injector_state.R14 = 0,
    injector_state.R15 = 0,
    injector_state.Rbp = 0,
    injector_state.Rsp = 0,
};
#else
typedef struct {
    uint32_t eax;
    uint32_t ebx;
    uint32_t ecx;
    uint32_t edx;
    uint32_t esi;
    uint32_t edi;
    uint32_t ebp;
    uint32_t esp;
} state_t;
state_t injector_state = {
    injector_state.eax = 0,
    injector_state.ebx = 0,
    injector_state.ecx = 0,
    injector_state.edx = 0,
    injector_state.esi = 0,
    injector_state.edi = 0,
    injector_state.ebp = 0,
    injector_state.esp = 0,
};
#endif

/* helpers */
// Not sure what is going on here tbh.
#define STR(x) #x
#define XSTR(x) STR(x)

/* x86/64 */

#define UD2_SIZE  2 // Undefined Instruction
#define PAGE_SIZE 4096
#define TF        0x100 // Trap Flag

/* injection stuff */

#define USE_TF true /* leave true, except when synthesizing some specific instructions */
typedef enum { RAND = 0x02, BRUTE = 0x04, TUNNEL = 0x06, DRIVEN = 0x08 } search_mode_t;
search_mode_t mode = TUNNEL; // RAND; //

void* packet_buffer; // Think of this like Protocol Fuzzing.
char* packet;
config_t config;


// Define a constant for the fiber stack size that is the size of a page
const DWORD FIBER_STACK_SIZE = PAGE_SIZE;

struct _EXCEPTION_POINTERS* ExceptionInfo;

//PVOID pFIBER_DATA = GetFiberData();

//LPVOID myFiber = CreateFiber(FIBER_STACK_SIZE, (LPFIBER_START_ROUTINE)MyFiberProc, NULL);// pFIBER_DATA);

#define MAX_INSN_LENGTH 15 /* actually 15 */
/* fault handler tries to use fault address to make an initial guess of
 * instruction length; but length of jump instructions can't be determined from
 * trap alone */
 /* set to this if something seems wrong */
#define JMP_LENGTH 16 // So, this essentially just truncates the length to 16 if insn exceeds 15. Not sure if this is good enough for 64bit machines

typedef struct insn_t {
    uint8_t bytes[MAX_INSN_LENGTH];
    size_t len; /* the number of specified bytes in the instruction */

    // constructor to set bytes and len
    insn_t(uint8_t byte = 0x00, size_t length = 0) {
        std::fill_n(bytes, MAX_INSN_LENGTH, byte);
        len = length;
    }
} insn_t;

typedef struct {
    insn_t i;
    int index;
    int last_len;
    int last_ec;
} inj_t;
inj_t inj;

static const insn_t null_insn = {}; // NUL insn. not a Nop, just a NUL

CONTEXT fault_context;

/* feedback */
typedef enum { TEXT=0x00, RAW=0x01 } output_t; // RAW Doesn't work
output_t output = TEXT;

#define TICK_MASK 0xffff

#define RAW_REPORT_INSN_BYTES 16

#define RAW_REPORT_DISAS_MNE false /* sifter assumes false */
#define RAW_REPORT_DISAS_MNE_BYTES 16
#define RAW_REPORT_DISAS_OPS false /* sifter assumes false */
#define RAW_REPORT_DISAS_OPS_BYTES 32
#define RAW_REPORT_DISAS_LEN true  /* sifter assumes true */
#define RAW_REPORT_DISAS_VAL true  /* sifter assumes true */

#pragma pack(push, 1) // ensure that structure is packed
typedef struct result_t{
    uint32_t valid;
    uintptr_t length;
    DWORD exceptionCode; // analogous to 'signum'
    uint32_t exceptionFlags; // analogous to 'si_code'
    PVOID faultingAddress; // analogous to 'addr'
}result_t;
#pragma pack(pop) // turn packing back to default
result_t result;

#pragma pack(push, 1) // ensure that structure is packed
typedef struct {
#ifdef RAW_REPORT_DISAS_MNE
    char mne[RAW_REPORT_DISAS_MNE_BYTES];
#endif
#ifdef RAW_REPORT_DISAS_OPS
    char ops[RAW_REPORT_DISAS_OPS_BYTES];
#endif
#ifdef RAW_REPORT_DISAS_LEN
    int len;
#endif
#ifdef RAW_REPORT_DISAS_VAL
    int val;
#endif
} disas_t;
disas_t disas;
#pragma pack(pop) // turn packing back to default

/* blacklists */

#define MAX_BLACKLIST 128

struct ignore_op_t {
    char* opcode;
    const char* reason;
};

// This might need to be edited. I am unsure if windows has a sysenter opcode.
ignore_op_t opcode_blacklist[MAX_BLACKLIST] = {
    { const_cast<char*>("\x0f\x34"), "sysenter" },
    { const_cast<char*>("\x0f\xa1"), "pop fs" },
    { const_cast<char*>("\x0f\xa9"), "pop gs" },
    { const_cast<char*>("\x8e"), "mov seg" },
    { const_cast<char*>("\xc8"), "enter" },
#ifndef _M_AMD64
    // vex in 64 (though still can be vex in 32...)
    { const_cast<char*>("\xc5"), "lds" },
    { const_cast<char*>("\xc4"), "les" },
#endif
    { const_cast<char*>("\x0f\xb2"), "lss" },
    { const_cast<char*>("\x0f\xb4"), "lfs" },
    { const_cast<char*>("\x0f\xb5"), "lgs" },
#ifdef _M_AMD64
    // 64 bit only - intel "discourages" using this without a rex* prefix, and
    // so capstone doesn't parse it
    { const_cast<char*>("\x63"), "movsxd" },
#endif
    /* segfaulting with various "mov sp" (always sp) in random synthesizing, too
    * tired to figure out why: 66 bc7453 */
    { const_cast<char*>("\xbc"), "mov sp" },
    /* segfaulting with "shr sp, 1" (always sp) in random synthesizing, too tired to
    * figure out why: 66 d1ec */
    /* haven't observed but assuming "shl sp, 1" and "sar sp, 1" fault as well */
    { const_cast<char*>("\xd1\xec"), "shr sp, 1" },
    { const_cast<char*>("\xd1\xe4"), "shl sp, 1" },
    { const_cast<char*>("\xd1\xfc"), "sar sp, 1" },
    /* same with "rcr sp, 1", assuming same for rcl, ror, rol */
    { const_cast<char*>("\xd1\xdc"), "rcr sp, 1" },
    { const_cast<char*>("\xd1\xd4"), "rcl sp, 1" },
    { const_cast<char*>("\xd1\xcc"), "ror sp, 1" },
    { const_cast<char*>("\xd1\xc4"), "rol sp, 1" },
    /* same with lea sp */
    { const_cast<char*>("\x8d\xa2"), "lea sp" },
    /* i guess these are because if you shift esp, you wind up way outside your
    * address space; if you shift sp, just a little, you stay in and crash */
    /* unable to resolve a constant length for xbegin, causes tunnel to stall */
    { const_cast<char*>("\xc7\xf8"), "xbegin" },
    /* int 80 will obviously cause issues */
    { const_cast<char*>("\xcd\x80"), "int 0x80" },
    /* as will syscall */
    { const_cast<char*>("\x0f\x05"), "syscall" },
    /* ud2 is an undefined opcode, and messes up a length differential search
    * b/c of the fault it throws */
    //{ const_cast<char*>("\x0f\xb9"), "ud2" },
    { NULL, NULL }
};


struct ignore_pre_t {
    const char* prefix;
    const char* reason;
};

#ifndef _M_AMD64
// avoid overwriting tls or something in 32 bit code LOL
ignore_pre_t prefix_blacklist[] = {
    { "\x65", "gs" },
    { NULL, NULL }
};
#else
ignore_pre_t prefix_blacklist[] = {
    { NULL, NULL }
};
#endif

struct range_t {
    insn_t start;
    insn_t end;
    bool started;

    // constructor to set start, end and started
    range_t(insn_t s = insn_t(), insn_t e = insn_t(), bool st = false)
        : start(s), end(e), started(st) {}
};

insn_t* range_marker = nullptr;
range_t search_range = {};
range_t total_range = range_t(insn_t(0x00, 0), insn_t(0xff, 0), false);

/* processes */
CRITICAL_SECTION pool_mutex;
CRITICAL_SECTION output_mutex;

/* synchronized output */
#define LINE_BUFFER_SIZE 256
#define BUFFER_LINES 16
#define SYNC_LINES_STDOUT BUFFER_LINES /* must be <= BUFFER_LINES */
#define SYNC_LINES_STDERR BUFFER_LINES /* must be <= BUFFER_LINES */
char stdout_buffer[LINE_BUFFER_SIZE * BUFFER_LINES];
char* stdout_buffer_pos = stdout_buffer;
int stdout_sync_counter = 0;
char stderr_buffer[LINE_BUFFER_SIZE * BUFFER_LINES];
char* stderr_buffer_pos = stderr_buffer;
int stderr_sync_counter = 0;

void initializeCriticalSections() {
    InitializeCriticalSection(&pool_mutex);
    InitializeCriticalSection(&output_mutex);
}

/*functions*/
#if USE_CAPSTONE
int print_asm(FILE* f);
#endif
void print_mc(FILE*, int);
bool is_prefix(uint8_t);
int prefix_count(void);
bool has_dup_prefix(void);
bool has_opcode(uint8_t*);
bool has_prefix(uint8_t*);
void preamble(void);
void inject(int);
void state_handler(EXCEPTION_POINTERS*);
//void fault_handler(EXCEPTION_POINTERS*);
//void configure_handler(void(*)(EXCEPTION_POINTERS*));
void give_result(FILE*);
void usage(void);
bool move_next_instruction(void);
bool move_next_range(void);
//LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS*);
LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo, FILE* f);

extern char debug, resume;
//extern char preamble_start, preamble_end;
int expected_length;

void sync_fprintf(FILE* f, const char* format, ...)
{
    va_list args;
    va_start(args, format);

    if (f == stdout) {
        int ret = vsnprintf_s(stdout_buffer_pos, LINE_BUFFER_SIZE * BUFFER_LINES - (stdout_buffer_pos - stdout_buffer), _TRUNCATE, format, args);
        if (ret >= 0) stdout_buffer_pos += ret;
    }
    else if (f == stderr) {
        int ret = vsnprintf_s(stderr_buffer_pos, LINE_BUFFER_SIZE * BUFFER_LINES - (stderr_buffer_pos - stderr_buffer), _TRUNCATE, format, args);
        if (ret >= 0) stderr_buffer_pos += ret;
    }
    else {
        assert(0);
    }

    va_end(args);
}

void sync_fwrite(const void* ptr, size_t size, size_t count, FILE* f)
{
    size_t stdout_buffer_size = LINE_BUFFER_SIZE * BUFFER_LINES; // initialize to your initial buffer size
    size_t stderr_buffer_size = LINE_BUFFER_SIZE * BUFFER_LINES; // initialize to your initial buffer size

    if (f == stdout)
    {
        // Ensure there's enough space
        if ((stdout_buffer_pos - stdout_buffer) + size * count > stdout_buffer_size)
        {
            // Reallocate the buffer to a larger size
            stdout_buffer_size *= 2;
            char* stdout_buffer = (char*)malloc(stdout_buffer_size);
            //stdout_buffer = static_cast<char*>(realloc(stdout_buffer, stdout_buffer_size));
        }

        // Copy data to the buffer
        memcpy(stdout_buffer_pos, ptr, size * count);
        stdout_buffer_pos += size * count;

        // frees the buffer
        free(stdout_buffer);
    }
    else if (f == stderr)
    {
        // Ensure there's enough space
        if ((stderr_buffer_pos - stderr_buffer) + size * count > stderr_buffer_size)
        {
            // Reallocate the buffer to a larger size
            stderr_buffer_size *= 2;
            char* stderr_buffer = (char*)malloc(stderr_buffer_size);
            //stderr_buffer = static_cast<char*>(realloc(stderr_buffer, stderr_buffer_size));
        }

        // Copy data to the buffer
        memcpy(stderr_buffer_pos, ptr, size * count);
        stderr_buffer_pos += size * count;

        // frees the buffer
        free(stderr_buffer);
    }
    else
    {
        assert(0);
    }
}

void sync_fflush(FILE* f, bool force)
{
    if (f == stdout) {
        stdout_sync_counter++;
        if (stdout_sync_counter == SYNC_LINES_STDOUT || force) {
            stdout_sync_counter = 0;
            EnterCriticalSection(&output_mutex);
            fwrite(stdout_buffer, 1, stdout_buffer_pos - stdout_buffer, f);
            fflush(f);
            LeaveCriticalSection(&output_mutex);
            stdout_buffer_pos = stdout_buffer;
        }
    }
    else if (f == stderr) {
        stderr_sync_counter++;
        if (stderr_sync_counter == SYNC_LINES_STDERR || force) {
            stderr_sync_counter = 0;
            EnterCriticalSection(&output_mutex);
            fwrite(stderr_buffer, 1, stderr_buffer_pos - stderr_buffer, f);
            fflush(f);
            LeaveCriticalSection(&output_mutex);
            stderr_buffer_pos = stderr_buffer;
        }
    }
    else {
        assert(0);
    }
}

void zero_insn_end(insn_t* insn, int marker)
{
    int i;
    for (i = marker; i < MAX_INSN_LENGTH; i++) {
        insn->bytes[i] = 0;
    }
}

bool increment_range(insn_t* insn, int marker)
{
    int i = marker - 1;
    zero_insn_end(insn, marker);

    if (i >= 0) {
        insn->bytes[i]++;
        while (insn->bytes[i] == 0) {
            i--;
            if (i < 0) {
                break;
            }
            insn->bytes[i]++;
        }
    }

    insn->len = marker;

    return i >= 0;
}

void print_insn(FILE* f, insn_t* insn)
{
    int i;
    for (i = 0; i < sizeof(insn->bytes); i++) {
        sync_fprintf(f, "%02x", insn->bytes[i]);
    }
}

void print_range(FILE* f, range_t* range)
{
    print_insn(f, &range->start);
    sync_fprintf(f, ";");
    print_insn(f, &range->end);
}

// Must call before creating new processes
void initialize_ranges(void)
{
    if (range_marker == NULL) {
        HANDLE hMapFile;

        hMapFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // use paging file
            NULL,                    // default security
            PAGE_READWRITE,          // read/write access
            0,                       // maximum object size (high-order DWORD)
            sizeof(*range_marker),   // maximum object size (low-order DWORD)
            TEXT("RangeMarkerMapObject"));  // name of mapping object

        if (hMapFile == NULL)
        {
            printf("Could not create file mapping object (%d).\n", GetLastError());
            return;
        }

        range_marker = (insn_t*)MapViewOfFile(hMapFile, // handle to map object
            FILE_MAP_ALL_ACCESS,  // read/write permission
            0,
            0,
            sizeof(*range_marker));

        if (range_marker == NULL)
        {
            printf("Could not map view of file (%d).\n", GetLastError());
            CloseHandle(hMapFile);
            return;
        }

        *range_marker = total_range.start;
    }
}

void free_ranges(void)
{
    if (range_marker != NULL) {
        UnmapViewOfFile(range_marker);

        // We also need to close the handle to the memory-mapped file
        HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, TEXT("RangeMarkerMapObject"));
        if (hMapFile != NULL) {
            CloseHandle(hMapFile);
        }

        range_marker = NULL;
    }
}

bool move_next_range(void)
{
    bool result = true;

    switch (mode) {
    case RAND:
    case DRIVEN:
        if (search_range.started) {
            result = false;
        }
        else {
            search_range = total_range;
            search_range.start.len = total_range.start.len; // ensure start length is set
        }
        break;
    case BRUTE:
    case TUNNEL:
        EnterCriticalSection(&pool_mutex);
        search_range.started = false;
        if (memcmp(range_marker->bytes, total_range.end.bytes,
            sizeof(range_marker->bytes)) == 0) {
            /* reached end of range */
            result = false;
        }
        else {
            search_range.start = *range_marker;
            search_range.start.len = range_marker->len; // ensure correct start length
            search_range.end = *range_marker;
            search_range.end.len = range_marker->len; // ensure correct end length

            if (!increment_range(&search_range.end, config.range_bytes)) {
                /* if increment rolled over, set to end */
                search_range.end = total_range.end;
                search_range.end.len = total_range.end.len; // ensure correct end length
            }
            else if (memcmp(search_range.end.bytes,
                total_range.end.bytes, sizeof(search_range.end.bytes)) > 0) {
                /* if increment moved past end, set to end */
                search_range.end = total_range.end;
                search_range.end.len = total_range.end.len; // ensure correct end length
            }

            *range_marker = search_range.end;
        }
        LeaveCriticalSection(&pool_mutex);
        break;
    default:
        assert(0);
    }

    return result;
}

#if USE_CAPSTONE
int print_asm(FILE* f)
{
    if (output == TEXT) {
        uint8_t* code = inj.i.bytes;
        size_t code_size = MAX_INSN_LENGTH;
        uint64_t address = (uintptr_t)packet_buffer;

        if (cs_disasm_iter(
            capstone_handle,
            (const uint8_t**)&code,
            &code_size,
            &address,
            capstone_insn)
            ) {
            sync_fprintf(
                f,
                "%10s %-45s (%2d)",
                capstone_insn[0].mnemonic,
                capstone_insn[0].op_str,
                (int)(address - (uintptr_t)packet_buffer)
            );
        }
        else {
            sync_fprintf(
                f,
                "%10s %-45s (%2d)",
                "(unk)",
                " ",
                (int)(address - (uintptr_t)packet_buffer)
            );
        }
        expected_length = (int)(address - (uintptr_t)packet_buffer);
    }

    return 0;
}
#endif

void print_mc(FILE* f, int length)
{
    int i;
    bool p = false;
    if (!is_prefix(inj.i.bytes[0])) {
        sync_fprintf(f, " ");
        p = true;
    }
    for (i = 0; i < length && i < MAX_INSN_LENGTH; i++) {
        sync_fprintf(f, "%02x", inj.i.bytes[i]);
        if (
            !p &&
            i < MAX_INSN_LENGTH - 1 &&
            is_prefix(inj.i.bytes[i]) &&
            !is_prefix(inj.i.bytes[i + 1])
            ) {
            sync_fprintf(f, " ");
            p = true;
        }
    }
}

bool is_prefix(uint8_t pre)
{
    return
        pre == 0xf0 || /* lock */
        pre == 0xf2 || /* repne / bound */
        pre == 0xf3 || /* rep */
        pre == 0x2e || /* cs / branch taken */
        pre == 0x36 || /* ss / branch not taken */
        pre == 0x3e || /* ds */
        pre == 0x26 || /* es */
        pre == 0x64 || /* fs */
        pre == 0x65 || /* gs */
        pre == 0x66 || /* data / operand override*/
        pre == 0x67    /* addr override*/
#ifdef _M_AMD64
        || (pre >= 0x40 && pre <= 0x4f) /* rex */
#endif
        ;
}

int prefix_count(void)
{
    int i;
    for (i = 0; i < MAX_INSN_LENGTH; i++) {
        if (!is_prefix(inj.i.bytes[i])) {
            return i;
        }
    }
    return i;
}

bool has_dup_prefix(void)
{
    int i;
    int byte_count[256];
    memset(byte_count, 0, 256 * sizeof(int));

    for (i = 0; i < MAX_INSN_LENGTH; i++) {
        if (is_prefix(inj.i.bytes[i])) {
            byte_count[inj.i.bytes[i]]++;
        }
        else {
            break;
        }
    }

    for (i = 0; i < 256; i++) {
        if (byte_count[i] > 1) {
            return true;
        }
    }

    return false;
}

//TODO: can't blacklist 00
bool has_opcode(uint8_t* op)
{
    int i, j;
    for (i = 0; i < MAX_INSN_LENGTH; i++) {
        if (!is_prefix(inj.i.bytes[i])) {
            j = 0;
            do {
                if (i + j >= MAX_INSN_LENGTH || op[j] != inj.i.bytes[i + j]) {
                    return false;
                }
                j++;
            } while (op[j]);

            return true;
        }
    }
    return false;
}

//TODO: can't blacklist 00
bool has_prefix(uint8_t* pre)
{
    int i, j;
    for (i = 0; i < MAX_INSN_LENGTH; i++) {
        if (is_prefix(inj.i.bytes[i])) {
            j = 0;
            do {
                if (inj.i.bytes[i] == pre[j]) {
                    return true;
                }
                j++;
            } while (pre[j]);
        }
        else {
            return false;
        }
    }
    return false;
}

void preamble_start(void) {
    // Your preamble code here
}
void preamble_end(void) {
    // Nothing here - this function is just a placeholder
}
void preamble()
{
#ifdef _M_AMD64
    preamble_start();
    unsigned __int64 flags = __readeflags();
    flags |= TF;
    __writeeflags(flags);
    preamble_end();
#else
    unsigned long flags = __readeflags();
    flags |= TF;
    __writeeflags(flags);
#endif
}


void inject(int insn_size)
{
    int i;
    ptrdiff_t preamble_length = (ptrdiff_t)preamble_end - (ptrdiff_t)preamble_start;

    static bool have_state = false;

    if (!USE_TF) { preamble_length = 0; }

    packet = (char*)packet_buffer + PAGE_SIZE - insn_size - preamble_length;

    for (i = 0; i < preamble_length; i++) {
        ((char*)packet)[i] = ((char*)&preamble_start)[i];
    }
    for (i = 0; i < MAX_INSN_LENGTH && i < insn_size; i++) {
        ((char*)packet)[i + preamble_length] = inj.i.bytes[i];
    }

    if (config.enable_null_access) {
        void* p = NULL;
        memset(p, 0, PAGE_SIZE); // change this to something that isn't memset
    }

    if (!have_state) {
        have_state = true;
        __ud2();  // This intrinsic triggers a UD2 instruction, causing a SIGILL.
    }

    // This is very system specific and could be different based on the architecture and the compiler.
#if _M_AMD64
    // Set general-purpose registers to the saved state.
    _mm_setcsr(injector_state.Rax);
    _mm_setcsr(injector_state.Rbx);
    _mm_setcsr(injector_state.Rcx);
    _mm_setcsr(injector_state.Rdx);
    _mm_setcsr(injector_state.Rsi);
    _mm_setcsr(injector_state.Rdi);
    _mm_setcsr(injector_state.R8);
    _mm_setcsr(injector_state.R9);
    _mm_setcsr(injector_state.R10);
    _mm_setcsr(injector_state.R11);
    _mm_setcsr(injector_state.R12);
    _mm_setcsr(injector_state.R13);
    _mm_setcsr(injector_state.R14);
    _mm_setcsr(injector_state.R15);
    _mm_setcsr(injector_state.Rbp);
    _mm_setcsr(injector_state.Rsp);

    // Then use some sort of function call or jump to the code at `packet`.
    ((void (*)())packet)();
#else
    // Set general-purpose registers to the saved state.
    _mm_setcsr(inject_state.eax);
    _mm_setcsr(inject_state.ebx);
    _mm_setcsr(inject_state.ecx);
    _mm_setcsr(inject_state.edx);
    _mm_setcsr(inject_state.esi);
    _mm_setcsr(inject_state.edi);
    _mm_setcsr(inject_state.ebp);
    _mm_setcsr(inject_state.esp);

    // Then use some sort of function call or jump to the code at `packet`.
    ((void (*)())packet)();
#endif
}

///* note: this does not provide an even distribution */
//void get_rand_insn_in_range(range_t* r)
//{
//    static uint8_t inclusive_end[MAX_INSN_LENGTH];
//    int i;
//    bool all_max = true;
//    bool all_min = true;
//
//    memcpy(inclusive_end, &r->end.bytes, MAX_INSN_LENGTH);
//    i = MAX_INSN_LENGTH - 1;
//    while (i >= 0) {
//        inclusive_end[i]--;
//        if (inclusive_end[i] != 0xff) {
//            break;
//        }
//        i--;
//    }
//
//    for (i = 0; i < MAX_INSN_LENGTH; i++) {
//        if (all_max && all_min) {
//            inj.i.bytes[i] =
//                rand() % (inclusive_end[i] - r->start.bytes[i] + 1) + r->start.bytes[i];
//        }
//        else if (all_max) {
//            inj.i.bytes[i] =
//                rand() % (inclusive_end[i] + 1);
//        }
//        else if (all_min) {
//            inj.i.bytes[i] =
//                rand() % (256 - r->start.bytes[i]) + r->start.bytes[i];
//        }
//        else {
//            inj.i.bytes[i] =
//                rand() % 256;
//        }
//        all_max = all_max && (inj.i.bytes[i] == inclusive_end[i]);
//        all_min = all_min && (inj.i.bytes[i] == r->start.bytes[i]);
//    }
//}

// Make sure to instantiate the engine and distribution only once
std::random_device rd;  // Will be used to obtain a seed for the random number engine
std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()

/* note: this should provide a more even distribution */
void get_rand_insn_in_range(range_t* r)
{
    static uint8_t inclusive_end[MAX_INSN_LENGTH];
    int i;
    bool all_max = true;
    bool all_min = true;

    memcpy(inclusive_end, &r->end.bytes, MAX_INSN_LENGTH);
    i = MAX_INSN_LENGTH - 1;
    while (i >= 0) {
        inclusive_end[i]--;
        if (inclusive_end[i] != 0xff) {
            break;
        }
        i--;
    }

    for (i = 0; i < MAX_INSN_LENGTH; i++) {
        std::uniform_int_distribution<> distr(0, 255); // define the range
        if (all_max && all_min) {
            distr = std::uniform_int_distribution<>(r->start.bytes[i], inclusive_end[i]);
        }
        else if (all_max) {
            distr = std::uniform_int_distribution<>(0, inclusive_end[i]);
        }
        else if (all_min) {
            distr = std::uniform_int_distribution<>(r->start.bytes[i], 255);
        }
        inj.i.bytes[i] = distr(gen);

        all_max = all_max && (inj.i.bytes[i] == inclusive_end[i]);
        all_min = all_min && (inj.i.bytes[i] == r->start.bytes[i]);
    }
}

void init_inj(const insn_t* new_insn)
{
    inj.i = *new_insn;
    inj.index = -1;
    inj.last_len = -1;
    inj.last_ec = -1;
}

bool move_next_instruction(void)
{
    int i;

    switch (mode) {
    case RAND:
        if (!search_range.started) {
            init_inj(&null_insn);
            get_rand_insn_in_range(&search_range);
        }
        else {
            get_rand_insn_in_range(&search_range);
        }
        break;
    case BRUTE:
        if (!search_range.started) {
            init_inj(&search_range.start);
            inj.index = config.brute_depth - 1;
        }
        else {
            for (inj.index = config.brute_depth - 1; inj.index >= 0; inj.index--) {
                inj.i.bytes[inj.index]++;
                if (inj.i.bytes[inj.index]) {
                    break;
                }
            }
        }
        break;
    case TUNNEL:
        if (!search_range.started) {
            init_inj(&search_range.start);
            inj.index = search_range.start.len;
            inj.last_ec = result.exceptionCode;
        }
        else {
            /* not a perfect algorithm; should really look at length
             * patterns of oher bytes at current index, not "last" length;
             * also situations in which this may not dig deep enough, should
             * really be looking at no length changes for n bytes, not just
             * last byte.  but it's good enough for now. */

             /* if the last iteration changed the instruction length, go deeper */
             /* but not if we're already as deep as the instruction goes */
            if ((result.length != inj.last_len || result.exceptionCode != inj.last_ec) && inj.index < result.length - 1) {
                inj.index++;
            }
            inj.last_len = result.length;
            inj.last_ec = result.exceptionCode; // store exception code

            inj.i.bytes[inj.index]++;

            while (inj.index >= 0 && inj.i.bytes[inj.index] == 0) {
                inj.index--;
                if (inj.index >= 0) {
                    inj.i.bytes[inj.index]++;
                }
                /* new tunnel level, reset length */
                inj.last_len = -1;
                inj.last_ec = -1;
            }
        }
        break;
    case DRIVEN:
        i = MAX_INSN_LENGTH;
        do {
            i -= fread(inj.i.bytes, 1, i, stdin);
        } while (i > 0);
        break;
    default:
        assert(0);
    }
    search_range.started = true;

    i = 0;
    while (opcode_blacklist[i].opcode) {
        if (has_opcode((uint8_t*)opcode_blacklist[i].opcode)) {
            switch (output) {
            case TEXT:
                sync_fprintf(stdout, "x: "); 
                print_mc(stdout, 16);
                sync_fprintf(stdout, "... \t\t(%s)\n", opcode_blacklist[i].reason);
                sync_fflush(stdout, false);
                break;
            case RAW:
                result = { 0,0,0,0,0 };
                give_result(stdout);
                break;
            default:
                assert(0);
            }
            return move_next_instruction();
        }
        i++;
    }

    i = 0;
    while (prefix_blacklist[i].prefix) {
        if (has_prefix((uint8_t*)prefix_blacklist[i].prefix)) {
            switch (output) {
            case TEXT:
                sync_fprintf(stdout, "x: "); 
                print_mc(stdout, 16);
                sync_fprintf(stdout, "... \t\t(%s)\n", prefix_blacklist[i].reason);
                sync_fflush(stdout, false);
                break;
            case RAW:
                result = { 0,0,0,0,0 };
                give_result(stdout);
                break;
            default:
                assert(0);
            }
            return move_next_instruction();
        }
        i++;
    }

    if (prefix_count() > config.max_prefix ||
        (!config.allow_dup_prefix && has_dup_prefix())) {
        switch (output) {
        case TEXT:
            sync_fprintf(stdout, "x: "); 
            print_mc(stdout, 16);
            sync_fprintf(stdout, "... \t\t(%s)\n", "prefix violation");
            sync_fflush(stdout, false);
            break;
        case RAW:
            result = { 0,0,0,0,0 };
            give_result(stdout);
            break;
        default:
            assert(0);
        }
        return move_next_instruction();
    }

    /* early exit */
    /* check if we are at, or past, the end instruction */
    if (memcmp(inj.i.bytes, search_range.end.bytes, sizeof(inj.i.bytes)) >= 0) {
        return false;
    }

    /* search based exit */
    switch (mode) {
        case RAND:
            return true;
        case BRUTE:
            return inj.index >= 0;
        case TUNNEL:
            return inj.index >= 0;
        case DRIVEN:
            return true;
        default:
            assert(0);
    }
}

void give_result(FILE* f)
{
    uint8_t* code;
    size_t code_size;
    uint64_t address;
    switch (output) {
    case TEXT:
        switch (mode) {
        case BRUTE:
        case TUNNEL:
        case RAND:
        case DRIVEN:
            sync_fprintf(f, " %s", expected_length == result.length ? " " : ".");
            sync_fprintf(f, "r: (%2d) ", result.length);
            if (result.exceptionCode == EXCEPTION_ACCESS_VIOLATION) { sync_fprintf(f, "access violation"); }             // SIGSEGV
            else if (result.exceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION) { sync_fprintf(f, "illegal instr"); }        //SIGILL
            else if (result.exceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) { sync_fprintf(f, "int div by zero"); }      // SIGFPE
            else if (result.exceptionCode == EXCEPTION_DATATYPE_MISALIGNMENT) { sync_fprintf(f, "data misalign"); }     // SIGBUS
            else if (result.exceptionCode == EXCEPTION_SINGLE_STEP) { sync_fprintf(f, "single step"); }                  // SIGTRAP
            sync_fprintf(f, " %3d ", result.exceptionFlags); // si_num 
            sync_fprintf(f, " %08x ", result.faultingAddress); // addr
            print_mc(f, result.length);
            sync_fprintf(f, "\n");
            break;
        default:
            assert(0);
        }
        break;
    case RAW:
#if USE_CAPSTONE
        code = inj.i.bytes;
        code_size = MAX_INSN_LENGTH;
        address = (uintptr_t)packet_buffer;

        if (cs_disasm_iter(
            capstone_handle,
            (const uint8_t**)&code,
            &code_size,
            &address,
            capstone_insn)
            ) {
#if RAW_REPORT_DISAS_MNE 
            strncpy(disas.mne, capstone_insn[0].mnemonic, RAW_DISAS_MNEMONIC_BYTES);
#endif
#if RAW_REPORT_DISAS_OPS
            strncpy(disas.ops, capstone_insn[0].op_str, RAW_DISAS_OP_BYTES);
#endif
#if RAW_REPORT_DISAS_LEN
            disas.len = (int)(address - (uintptr_t)packet_buffer);
#endif
#if RAW_REPORT_DISAS_VAL
            disas.val = true;
#endif
        }
        else {
#if RAW_REPORT_DISAS_MNE 
            strncpy(disas.mne, "(unk)", RAW_DISAS_MNEMONIC_BYTES);
#endif
#if RAW_REPORT_DISAS_OPS
            strncpy(disas.ops, " ", RAW_DISAS_OP_BYTES);
#endif
#if RAW_REPORT_DISAS_LEN
            disas.len = (int)(address - (uintptr_t)packet_buffer);
#endif
#if RAW_REPORT_DISAS_VAL
            disas.val = false;
#endif
        }
#if RAW_REPORT_DISAS_MNE || RAW_REPORT_DISAS_OPS || RAW_REPORT_DISAS_LEN
        sync_fwrite(&disas, sizeof(disas), 1, stdout);
#endif
#endif
        sync_fwrite(inj.i.bytes, RAW_REPORT_INSN_BYTES, 1, stdout);
        sync_fwrite(&result, sizeof(result), 1, stdout);
        /* fflush(stdout); */
        break;
    default:
        assert(0);
    }
    sync_fflush(stdout, false);
}

void usage(void)
{
    printf("injector [-b|-r|-t|-d] [-R|-T] [-x] [-0] [-D] [-N]\n");
    printf("\t[-s seed] [-B brute_depth] [-P max_prefix]\n");
    printf("\t[-i instruction] [-e instruction]\n");
    printf("\t[-c core] [-X blacklist]\n");
    printf("\t[-j jobs] [-l range_bytes]\n");
}

void help(void)
{
    printf("injector [OPTIONS...]\n");
    printf("\t[-b|-r|-t|-d] ....... mode: brute, random, tunnel, directed (default: tunnel)\n");
    printf("\t[-R|-T] ............. output: raw, text (default: text)\n");
    printf("\t[-x] ................ show tick (default: %d)\n", config.show_tick);
    printf("\t[-0] ................ allow null dereference (default: %d)\n", config.enable_null_access);
    printf("\t[-D] ................ allow duplicate prefixes (default: %d)\n", config.allow_dup_prefix);
    printf("\t[-N] ................ no nx bit support (default: %d)\n", config.nx_support);
    printf("\t[-s seed] ........... in random search, seed (default: time(0))\n");
    printf("\t[-B brute_depth] .... in brute search, maximum search depth (default: %d)\n", config.brute_depth);
    printf("\t[-P max_prefix] ..... maximum number of prefixes to search (default: %d)\n", config.max_prefix);
    printf("\t[-i instruction] .... instruction at which to start search, inclusive (default: 0)\n");
    printf("\t[-e instruction] .... instruction at which to end search, exclusive (default: ff..ff)\n");
    printf("\t[-c core] ........... core on which to perform search (default: any)\n");
    printf("\t[-X blacklist] ...... blacklist the specified instruction\n");
    printf("\t[-j jobs] ........... number of simultaneous jobs to run (default: %d)\n", config.jobs);
    printf("\t[-l range_bytes] .... number of base instruction bytes in each sub range (default: %d)\n", config.range_bytes);
}

void init_config(int argc, char** argv)
{
    int c, i, j;
    bool seed_given = false;
    for (int optind = 1; optind < argc; ++optind) {
        if (argv[optind][0] == '-') {
            switch (argv[optind][1]) {
            case '?':
                help();
                exit(-1);
                break;
            case 'b':
                mode = BRUTE;
                break;
            case 'r':
                mode = RAND;
                break;
            case 't':
                mode = TUNNEL;
                break;
            case 'd':
                mode = DRIVEN;
                break;
            case 'R':
                output = RAW;
                break;
            case 'T':
                output = TEXT;
                break;
            case 'x':
                config.show_tick = true;
                break;
            case '0':
                config.enable_null_access = true;
                break;
            case 'N':
                config.nx_support = false;
                break;
            case 's':
                config.seed = std::stoi(argv[++optind]);
                seed_given = true;
                break;
            case 'P':
                config.max_prefix = std::stoi(argv[++optind]);
                break;
            case 'B':
                config.brute_depth = std::stoi(argv[++optind]);
                break;
            case 'D':
                config.allow_dup_prefix = true;
                break;
            case 'i':
                if (optind + 1 < argc) {
                    std::string insn = argv[++optind];
                    i = 0;
                    while (i < insn.length() / 2 && i < MAX_INSN_LENGTH) {
                        std::string byteString = insn.substr(i * 2, 2);
                        total_range.start.bytes[i] = static_cast<char>(std::stoi(byteString, nullptr, 16));
                        i++;
                    }
                    total_range.start.len = i;
                    while (i < MAX_INSN_LENGTH) {
                        total_range.start.bytes[i] = 0;
                        i++;
                    }
                }
                else {
                    std::cerr << "Option -i requires an argument.\n";
                    exit(-1);
                }
                break;
            case 'e':
                if (optind + 1 < argc) {
                    std::string optarg = argv[++optind];
                    i = 0;
                    while (i < optarg.length() / 2 && i < MAX_INSN_LENGTH) {
                        std::string byteString = optarg.substr(i * 2, 2);
                        total_range.end.bytes[i] = static_cast<char>(std::stoi(byteString, nullptr, 16));
                        i++;
                    }
                    total_range.end.len = i;
                    while (i < MAX_INSN_LENGTH) {
                        total_range.end.bytes[i] = 0;
                        i++;
                    }
                }
                else {
                    std::cerr << "Option -e requires an argument.\n";
                    exit(-1);
                }
                break;
            case 'c':
                config.force_core = true;
                config.core = std::stoi(argv[++optind]);
                break;
            case 'X':
                if (optind + 1 < argc) {
                    std::string optarg = argv[++optind];
                    j = 0;
                    while (opcode_blacklist[j].opcode) {
                        j++;
                    }
                    opcode_blacklist[j].opcode = new char[optarg.length() / 2 + 1];
                    assert(opcode_blacklist[j].opcode);
                    i = 0;
                    while (i < optarg.length() / 2) {
                        std::string byteString = optarg.substr(i * 2, 2);
                        opcode_blacklist[j].opcode[i] = static_cast<char>(std::stoi(byteString, nullptr, 16));
                        i++;
                    }
                    opcode_blacklist[j].opcode[i] = '\0';
                    opcode_blacklist[j].reason = "user_blacklist";
                    opcode_blacklist[++j] = { nullptr, nullptr };
                }
                else {
                    std::cerr << "Option -X requires an argument.\n";
                    exit(-1);
                }
                break;
            case 'j':
                config.jobs = std::stoi(argv[++optind]);
                break;
            case 'l':
                config.range_bytes = std::stoi(argv[++optind]);
                break;
            default:
                usage();
                exit(-1);
            }
        }
    }

    if (!seed_given) {
        config.seed = time(0);
    }
}


void pin_core(void)
{
    if (config.force_core) {
        DWORD_PTR mask = static_cast<DWORD_PTR>(1) << config.core; // assuming config.core is the number of the core you want to pin to
        if (!SetThreadAffinityMask(GetCurrentThread(), mask)) {
            printf("error: failed to set cpu\n");
            exit(1);
        }
    }
}

void tick(void)
{
    static uint64_t t = 0;
    if (config.show_tick) {
        t++;
        if ((t & TICK_MASK) == 0) {
            fprintf(stderr, "t: ");
            print_mc(stderr, 16);
            fprintf(stderr, "... ");
#if USE_CAPSTONE
            print_asm(stderr);
            fprintf(stderr, "\t");
#endif
            give_result(stderr);
            fflush(stderr);
        }
    }
}

void pretext(void)
{
    /* assistive output for analyzing hangs in text mode */
    if (output == TEXT) {
        sync_fprintf(stdout, "r: ");
        print_mc(stdout, 16);
        sync_fprintf(stdout, " ");
#if USE_CAPSTONE
        print_asm(stdout);
        sync_fprintf(stdout, " ");
#endif
        sync_fflush(stdout, false);
    }
}

void ConfigureExceptionHandler(LONG(WINAPI* handler)(EXCEPTION_POINTERS*))
{
    SetUnhandledExceptionFilter(handler);
}

/*Main stuff*/

typedef void (*SimpleFunction)(); // this is probably suppose to be the injection

LONG WINAPI MyExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo, FILE* f)
{
    // Here you get access to the CONTEXT structure, which contains the CPU registers
    CONTEXT* context = ExceptionInfo->ContextRecord;

    // Fault Context
    fault_context = *(ExceptionInfo->ContextRecord);

    ptrdiff_t preamble_length = (ptrdiff_t)preamble_end - (ptrdiff_t)preamble_start;

    if (!USE_TF) { preamble_length = 0; }

    /* make an initial estimate on the instruction length from the fault address */
    uintptr_t insn_length = (uintptr_t)context->Rip - (uintptr_t)packet - preamble_length;

    // result
    result.valid = 1;
    //result.length = insn_length; // or any appropriate value
    result.exceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
    result.exceptionFlags = ExceptionInfo->ExceptionRecord->ExceptionFlags;
    result.faultingAddress = ExceptionInfo->ExceptionRecord->ExceptionAddress;

    if (insn_length < 0) {
        insn_length = JMP_LENGTH;
    }
    else if (insn_length > MAX_INSN_LENGTH) {
        insn_length = JMP_LENGTH;
    }

    switch (result.exceptionCode) {
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        return EXCEPTION_EXECUTE_HANDLER;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
        return EXCEPTION_EXECUTE_HANDLER;
    case EXCEPTION_ACCESS_VIOLATION:
        return EXCEPTION_EXECUTE_HANDLER;
    case EXCEPTION_DATATYPE_MISALIGNMENT:
        return EXCEPTION_EXECUTE_HANDLER;
    case EXCEPTION_SINGLE_STEP:
        return EXCEPTION_EXECUTE_HANDLER;
    default:
        assert(0);
    }

    //    if (ExceptionInfo->ExceptionRecord->NumberParameters >= 2)
    //    {
    //        //std::cout << "Access violation type: ";
    //        //switch (result.exceptionFlags) //ExceptionInfo->ExceptionRecord->ExceptionInformation[0])
    //        //{
    //        //case 0: std::cout << "Read violation"; break;
    //        //case 1: std::cout << "Write violation"; break;
    //        //case 8: std::cout << "DEP violation"; break;
    //        //default: std::cout << "Unknown violation type"; break;
    //        //}
    //        //std::cout << std::endl;

    return EXCEPTION_CONTINUE_SEARCH;
}

//int MyExceptionFilter(EXCEPTION_POINTERS* pExceptionPointers) {
//    // Get the exception record
//    EXCEPTION_RECORD* pRec = pExceptionPointers->ExceptionRecord;
//
//    // Check if the exception code is an access violation
//    if (pRec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
//        // Get the address that caused the fault
//        PVOID faultAddress = (PVOID)pRec->ExceptionInformation[1];
//
//        std::cout << "Access violation at address: " << faultAddress << std::endl;
//
//        return EXCEPTION_EXECUTE_HANDLER;
//    }
//
//    return EXCEPTION_CONTINUE_SEARCH;
//}

int main(int argc, char** argv) {

    int job = 0;
    int insn_size;
    void* packet_buffer_unaligned;
    void* np = nullptr;
    DWORD oldProtect;

    initializeCriticalSections();
    init_config(argc, argv);
    pin_core();
    srand(config.seed);

    // allocate and protect memory with VirtualAlloc. This creates one big page the size of three, then seperates it into two. one exactly one page and another two pages in size.
    packet_buffer_unaligned = VirtualAlloc(NULL, PAGE_SIZE*3, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    packet_buffer = (void*)(((uintptr_t)packet_buffer_unaligned + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1));

    if (config.nx_support) {
        // Change the page protection
        //assert(VirtualProtect(packet_buffer + PAGE_SIZE, PAGE_SIZE, PAGE_READWRITE, NULL));
        if (!VirtualProtect(&packet_buffer + PAGE_SIZE, PAGE_SIZE, PAGE_READWRITE, &oldProtect)) {
            // Handle the error
            std::cerr << "Failed to change memory protection.\n";
        }
    }
    else {
        // Change the page protection
        if (!VirtualProtect(&packet_buffer + PAGE_SIZE, PAGE_SIZE, PAGE_NOACCESS, &oldProtect)) {
            // Handle the error
            std::cerr << "Failed to change memory protection.\n";
            //assert(VirtualProtect(packet_buffer + PAGE_SIZE, PAGE_SIZE, PAGE_NOACCESS, NULL));
        }
    }

#if USE_CAPSTONE
    if (cs_open(CS_ARCH_X86, CS_MODE, &capstone_handle) != CS_ERR_OK) {
        exit(1);
    }
    capstone_insn = cs_malloc(capstone_handle);
#endif

    if (config.enable_null_access) {
        np = VirtualAlloc(0, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);
        if (np == NULL) {
            printf("null access requires running with appropriate permissions\n");
            exit(1);
        }
    }

    initialize_ranges();

    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    TCHAR szCmdline[] = TEXT("MyChildProcess");
    PROCESS_INFORMATION* pid = new PROCESS_INFORMATION[config.jobs - 1];
    for (int i = 0; i < config.jobs - 1; i++) {
        BOOL success = CreateProcess(NULL, szCmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

        assert(success != 0);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    
    while (move_next_range()) {
        while (move_next_instruction()) {
            pretext();
            for (insn_size = 1; insn_size <= MAX_INSN_LENGTH; insn_size++) {
                __try {
                    // your code here
                   inject(insn_size);
                   result.length = insn_size;
                }
                __except (MyExceptionFilter(GetExceptionInformation(), stdout)) {
                    
                    if ((expected_length == result.length)) { // Figure out how to use exception filter here
                        // Here we might perform the equivalent operation as the UNIX version
                        result.length = expected_length;
                        continue;
                        //break;
                    }
                    else 
                    {
                        result.length = insn_size;
                        continue;
                    }
                }
            }
            give_result(stdout);
            tick();
            
        }
    }

    sync_fflush(stdout, true);
    sync_fflush(stderr, true);

#if USE_CAPSTONE
    cs_free(capstone_insn, 1);
    cs_close(&capstone_handle);
#endif

    if (config.enable_null_access) {
        VirtualFree(np, 0, MEM_RELEASE);
    }

    VirtualFree(packet_buffer_unaligned, 0, MEM_RELEASE);

    if (pid != 0) {
        for (int i = 0; i < config.jobs - 1; i++) {
            // Assuming that pid is an array of PROCESS_INFORMATION types.
            WaitForSingleObject(pid[i].hProcess, INFINITE);
        }
        free_ranges();
        DeleteCriticalSection(&pool_mutex);
        DeleteCriticalSection(&output_mutex);
    }

    /**
    // Allocate two consecutive pages
    //void* ptr = VirtualAlloc(NULL, 2 * PAGE_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    //if (ptr == NULL) {
    //    // handle error
    //    printf("VirtualAlloc failed\n");
    //    return 1;
    //}
    //// Clear the pages to zero
    ////memset(ptr, 0, 2 * 4096);

    //// Change the second page to read/write
    //DWORD oldProtect;
    //if (!VirtualProtect((char*)ptr + PAGE_SIZE, PAGE_SIZE, PAGE_READWRITE, &oldProtect)) {
    //    // handle error
    //    printf("VirtualProtect failed\n");
    //    return 1;
    //}

    //// IA-64 instructions to move 42 into the EAX register then return
    ////unsigned char code[] = {
    ////    // mov rax, 42
    ////    // ret
    ////    0x48, 0xC7, 0xC0, 0x2A, 0x00, 0x00, 0x00, 0xC3
    ////};

    //// IA-32 instructions to move 42 into the EAX register then return
    //unsigned char code[] = {
    //    // mov eax, 42
    //    // ret
    //    //0xB8, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x90,
    //    // punpckhdq mm4,mmword ptr
    //    //0x0F, 0x6A, 0x60, 0x6A,
    //    //0x43, 0xDF, 0xC7, 0x00,
    //    //0xF3, 0x0F, 0x1E, 0xFB,
    //    //0x66, 0x0F, 0x38, 0x82,
    //    //0x66, 0xE8, 0x00, 0x00, 0x00, 0x01, 
    //    //0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
    //    //0x0F, 0x0D, 0x00,
    //    //0x0F, 0x1F, 
    //    //0x0F, 0x01, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00,
    //    //0x65, 0x4D, 0x4F, 0x4E, 0x4B, 0x45, 0x59,
    //    0xF3, 0xC3
    //};

    //// Copy the first byte of the instructions to the end of the first page
    //memcpy((char*)ptr + PAGE_SIZE - 1, code, 1);

    //// Copy the rest of the instructions to the start of the second page
    //memcpy((char*)ptr + PAGE_SIZE, code + 1, sizeof(code) - 1);

    //// Allocate space for the executed bytes
    //
    //unsigned char* executedBytes = (unsigned char*)malloc(PAGE_SIZE*2);
    ////executedBytes[0] = code[0];
    //size_t size = 0;

    //// Attempt to execute instructions until no access violation occurs
    //bool instructionExecuted = false;
    //while (size < sizeof(code) && !instructionExecuted) {
    //    __try {
    //        
    //        std::cout << "Size: " << size << std::endl; // make size dynamic
    //        // Tries to fetch the last byte in the first array
    //        SimpleFunction function = (SimpleFunction)((char*)ptr + PAGE_SIZE - 1); //void (*function)() = (void(*)())ptr;
    //        function();
    //        // if execution is successful, all code has been moved and executed
    //        instructionExecuted = true;
    //    } __except (MyExceptionFilter(GetExceptionInformation())) {
    //        // Save the byte to be moved
    //        executedBytes[size] = *((char*)ptr + PAGE_SIZE + size);

    //        // Copy the saved byte to the end of the first page
    //        memcpy((char*)ptr + PAGE_SIZE - 1, &executedBytes[size], 1);
    //        ++size;

    //        // If there is still code left, copy it to the start of the second page
    //        if (size < sizeof(code) - 1)
    //            memcpy((char*)ptr + PAGE_SIZE, code + size, sizeof(code) - size);
    //    }
    //    // Print the bytes that were executed
    //    std::cout << "Executed bytes: ";
    //    for (size_t i = 0; i < size; ++i) {
    //        //std::cout << std::hex << static_cast<int>(executedBytes[i]) << " "; // When the executed bytes don't line up with the code it is the length of the instruction
    //        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(code[i]) << " ";
    //    }
    //    std::cout << std::endl;
    //}


    //// Free the executedBytes
    //free(executedBytes);

    //// Deallocate the memory
    //if (!VirtualFree(ptr, 0, MEM_RELEASE)) {
    //    // handle error
    //    printf("VirtualFree failed\n");
    //    return 1;
    //}
    **/
    return 0;
}
